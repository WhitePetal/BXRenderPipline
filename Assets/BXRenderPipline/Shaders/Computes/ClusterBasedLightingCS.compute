#pragma kernel CSMain

#include "Assets/BXRenderPipline/Shaders/Libiary/AllCommon.hlsl"

// outpus
RWStructuredBuffer<uint> _TileLightingIndices;
RWStructuredBuffer<uint> _TileLightingDatas;

// inputs
#define MAX_POINT_LIGHT_COUNT 256
int _PointLightCount;
float4 _PointLightSpheres[MAX_POINT_LIGHT_COUNT];
float4 _TileLBStart;
float4 _CameraForward;
float4 _TileRVec;
float4 _TileUVec;
float4 _ClusterSize;
float4x4 BX_MatrixV;
float4 _ZBufferParams;
float4 _ScreenParams;
float4 _ProjectionParams;

// temps
groupshared uint tileVisibleLightCount = 0;

inline float Linear01Depth( float z )
{
    return 1.0 / (_ZBufferParams.x * z + _ZBufferParams.y);
}

inline float LinearEyeDepth( float z )
{
    return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w);
}

bool IntersectTileAndPointLight(float zMin, float zMax, uint3 groupId, float4 lightSphere)
{
    float3 bextent = lightSphere.www;

    float4 frustume[6];

    frustume[0] = float4(0, 0, 1, -zMax);
    frustume[1] = float4(0, 0, -1, zMin);

    float3 v0 = normalize(_TileLBStart.xyz + _TileRVec.xyz * groupId.x + _TileUVec.xyz * groupId.y);
    float3 v1 = normalize(v0 + _TileUVec.xyz);

    float3 n2 = cross(v1, v0);
    frustume[2] = float4(n2, 0);

    float3 v2 = normalize(v0 +_TileRVec.xyz);
    float3 v3 = normalize(v0 + _TileRVec.xyz + _TileUVec.xyz);

    float3 n3 = cross(v2, v3);
    frustume[3] = float4(n3, 0);
    float3 n4 = cross(v3, v1);
    frustume[4] = float4(n4, 0);
    float3 n5 = cross(v0, v2);
    frustume[5] = float4(n5, 0);

    [unroll(6)]
    for(uint k = 0; k < 6; ++k)
    {
        // https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_plane.html AABB-平面相交
        float4 plane = frustume[k];
        float3 n = plane.xyz;
        float3 n_abs = abs(n);
        float d = plane.w;
        float r = dot(bextent, n_abs);
        float s = dot(n, lightSphere.xyz) + d;
        
        [branch]
        if((-r - s) > 0)
        {
            return false;
        }
    }
    return true;
}

[numthreads(16,16,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GROUPINDEX, uint3 groupId : SV_GROUPID)
{   
    uint k = groupId.z;
    uint tileIndex = k * 16 * 32 + (groupId.y * 32 + groupId.x);
    if(groupIndex == 0)
    {
        tileVisibleLightCount = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    [branch]
    if (groupIndex < (uint)_PointLightCount)
    {
        float4 lightSphere = _PointLightSpheres[groupIndex];
        lightSphere.xyz = mul(BX_MatrixV, float4(lightSphere.xyz, 1.0)).xyz;
        float nearK = -_ProjectionParams.y*pow(_ClusterSize.z, k);
        if(IntersectTileAndPointLight(nearK, nearK * _ClusterSize.z, groupId, lightSphere))
        {
            uint offset;
            InterlockedAdd(tileVisibleLightCount, 1, offset);
            _TileLightingIndices[tileIndex * 256 + offset] = groupIndex;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    if(groupIndex == 0)
    {
        _TileLightingDatas[tileIndex] = tileVisibleLightCount;
    }
}
