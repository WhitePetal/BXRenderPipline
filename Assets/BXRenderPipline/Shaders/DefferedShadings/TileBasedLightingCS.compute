#pragma kernel CSMain

#include "Assets/BXRenderPipline/Shaders/Libiary/AllCommon.hlsl"

// outpus
RWStructuredBuffer<uint> _TileLightingIndices;
RWStructuredBuffer<uint> _TileLightingDatas;

// inputs
#define MAX_POINT_LIGHT_COUNT 256
float4 _PointLightSpheres[MAX_POINT_LIGHT_COUNT];
Texture2D _BXDepthNormalBuffer;
SamplerState sampler_point_clamp;
float4 _ScreenParams;
float4 _ProjectionParams;
float3 _WorldSpaceCameraPos;
float4x4 _ViewPortRays;

// temps
groupshared uint tileMinDepth = 0xFFFFFFFF;
groupshared uint tileMaxDepth = 0;
groupshared uint tileVisibleLightCount = 0;

bool IntersectTileAndPointLight(float zMin, float zMax, uint3 groupId, float4 lightSphere)
{
    float2 tileScreenUVLB = float2(groupId.x * 16 / _ScreenParams.x, groupId.y * 16 / _ScreenParams.y);
    float2 tileScreenUVRU = float2((groupId.x + 1) * 16 / _ScreenParams.x, (groupId.y + 1) * 16 / _ScreenParams.y);

    float3 lb = normalize(_ViewPortRays[2].xyz);
    float3 rb = normalize(_ViewPortRays[3].xyz);
    float3 lu = normalize(_ViewPortRays[0].xyz);
    float3 ru = normalize(_ViewPortRays[1].xyz);

    float3 LU = lerp(lu, ru, tileScreenUVLB.x);
    float3 LB = lerp(lb, lu, tileScreenUVLB.x);
    float3 bMin = _WorldSpaceCameraPos.xyz + lerp(LB, LU, tileScreenUVLB.y) * zMin;

    float3 RU = lerp(lu, ru, tileScreenUVRU.x);
    float3 RB = lerp(lb, lu, tileScreenUVRU.x);
    float3 bMax = _WorldSpaceCameraPos.xyz + lerp(RB, RU, tileScreenUVRU.y) * zMax;

    bMax = max(bMax, bMin);
    bMin = min(bMax, bMin);

    float ww = lightSphere.w * lightSphere.w;

    half dmin = 0;
    [unroll]
    for(int i = 0; i < 3; ++i)
    {
        dmin += lightSphere[i] < bMin[i] ? (lightSphere[i] - bMin[i]) * (lightSphere[i] - bMin[i]) : 0;
        dmin += lightSphere[i] > bMax[i] ? (lightSphere[i] - bMax[i]) * (lightSphere[i] - bMax[i]) : 0;
    }

    return dmin <= ww;
}

[numthreads(16,16,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GROUPINDEX, uint3 groupId : SV_GROUPID)
{
    if(groupIndex == 0)
    {
        tileMinDepth = 0xFFFFFFFF;
        tileMaxDepth = 0;
        tileVisibleLightCount = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    float4 depthNormalData = _BXDepthNormalBuffer.SampleLevel(sampler_point_clamp, (float2)id.xy / _ScreenParams.xy, 0);
    float3 n;
    float depth01;
    DecodeDepthNormal(depthNormalData, depth01, n);
    float depth = depth01 * _ProjectionParams.z;
    InterlockedMin(tileMinDepth,asuint(depth));
    InterlockedMax(tileMaxDepth,asuint(depth));
    GroupMemoryBarrierWithGroupSync();

    float4 lightSphere = _PointLightSpheres[groupIndex];
    uint tileIndex = groupId.y * _ScreenParams.x / 16 + groupId.x;
    if (IntersectTileAndPointLight(asfloat(tileMinDepth), asfloat(tileMaxDepth), groupId, lightSphere))
    {
        uint offset;
        InterlockedAdd(tileVisibleLightCount, 1, offset);
        _TileLightingIndices[tileIndex * 256 + offset] = groupIndex;
    }
    GroupMemoryBarrierWithGroupSync();
    if(groupIndex == 0)
    {
        _TileLightingDatas[tileIndex] = tileVisibleLightCount;
    }
    GroupMemoryBarrierWithGroupSync();
}
